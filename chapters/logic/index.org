* Logic Programming with Clojure's core.logic

  =core.logic= is a library for logic programming in Clojure.

** Basic Setup

   Before we can start to use =core.logic=, we need to take care of a
   little setup. It's super short and easy, I promise.

*** Leiningen Project

    The Leiningen project setup is very simple. Basically only the
    =core.logic= dependency needs to be added:

    #+BEGIN_SRC clojure :tangle project.clj
    (defproject clojure-literally/logic "0.1.0-SNAPSHOT"
      :dependencies [[org.clojure/clojure "1.7.0"]
                     [org.clojure/core.logic "0.8.10"]])
    #+END_SRC

*** Use the library

    To use =core.logic= simply require it in a REPL session:

    #+BEGIN_SRC clojure :results none
    (require '[clojure.core.logic :as l])
    #+END_SRC

    When not only working in a REPL, but with persistent source code
    files, you should add the =require= to the namespace
    declaration. Business as usual!

** Getting Started
*** Logic Variables

    Logic variables can take ambiguous values, but only one value at a
    time. The solver (core.logic basically) can determine all the
    values for which given constraints are true. So what are those
    constraints?

*** Constraints

    Constraints are expressions that must be true for valid Logic
    Variables. As such, =core.logic= can find all Logic Variables that
    satisfy the given set of constraints.

    Let us have a look at a simple example.

    Here is a very basic example:

    #+NAME: example-1
    #+BEGIN_SRC clojure :results verbatim :exports both :post comment-results(result=*this*)
    (l/run* [q]
      (l/membero q [1 2 3])
      (l/membero q [2 3 4]))
    #+END_SRC

    #+RESULTS: example-1
    : ;=> (2 3)

    The result call_example-1[:post]() is a list of elements that are
    present in both vectors passed to =l/membero=. Both calls of
    =l/membero= define a logic expression. In this case, that the
    logic variable =q= needs to be a member of both these
    vectores. =l/run*= passes the expressions to the =clojure.core=
    logic solver, which then finds all possible values of =q= that
    are compliant with the logic expressions.

    =l/membero= is straight forward, a logical expression such that a
    value is an element of a collection:

    #+BEGIN_SRC clojure :results output verbatim :exports both
    (doc l/membero)
    #+END_SRC

    #+RESULTS:
    : -------------------------
    : clojure.core.logic/membero
    : ([x l])
    :   A relation where l is a collection, such that l contains x.


*** Anything

    Logcial expressions can easily have more than one logic variable
    that complies with them. We already saw this in the [[*Constraints][constraints
    example]]. The possible results might be very long and you might not
    be interested in all of them. in such cases use =l/run=:

    #+BEGIN_SRC clojure :results output
    (doc l/run)
    #+END_SRC

    #+RESULTS:
    : -------------------------
    : clojure.core.logic/run
    : ([n bindings & goals])
    : Macro
    :   Executes goals until a maximum of n results are found.

    With =l/run= we can specify the maximum number of results. Here is
    an example:

    #+BEGIN_SRC clojure :results verbatim :exports both
    (l/run 3 [q]
      (l/membero q (range 200 1000 12)))
    #+END_SRC

    #+RESULTS:
    : (200 212 224)

    But what happens if *anything* would fulfill the logic expressions?

    #+BEGIN_SRC clojure :exports both :results verbatim
    (l/run* [q]
      (l/== q q))
    #+END_SRC

    #+RESULTS:
    : (_0)

    The result =_0= indicates, that any value would comply with the
    constraints. =_= stands for anything and =0= is an index. To
    understand why there is an index, have a look at the following
    example:

    #+BEGIN_SRC clojure :exports both :results verbatim
    (l/run* [q p]
      (l/== q q)
      (l/== p p))
    #+END_SRC

    #+RESULTS:
    : ([_0 _1])

    =q= and =p= can be anything and they can be different. Being
    different is indicated with the indices. =_0= is anything and =_1=
    is another anything. So whatever =q= and =p= are, they are
    independent and satisfy the logical expressions.

    With a simple, additional logic expression, both =q= and =p= need
    to be identical:

    #+BEGIN_SRC clojure :exports both :results verbatim
    (l/run* [q p]
      (l/== q q)
      (l/== p p)
      (l/== q p))
    #+END_SRC

    #+RESULTS:
    : ([_0 _0])

    =q= and =p= can be anything, as long as they are identical. =q=
    and =p= both need to be =_0= at the same time. This is indicated
    by using the same index =0= on the "anything expression" =_=.

** Resources

    - [[https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer][The official core.logic primer]]

** Helpers

   A source block used to indicate a result in an source code block.
   #+NAME: comment-results
   #+BEGIN_SRC clojure :var result="" :exports none
   (str ";=> " result)
   #+END_SRC

*** TODO Move to some kind of library to share code with other chapters
