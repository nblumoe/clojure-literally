#+TITLE: XML Processing
#+AUTHOR: Nils Blum-Oeste
#+PROPERTY: header-args :tangle yes

* xml

  Start writing the chapter here.
* Web Resources
  http://blog.korny.info/2014/03/08/xml-for-fun-and-profit.html

* Project Setup

  #+BEGIN_SRC clojure :tangle project.clj
  (defproject clojure-literally/xml "0.1.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/data.xml "0.0.8"]])
  #+END_SRC

* Creating XML

  At first, we want to create some XML with Clojure. Later we will parse the XML
  again.

  Require the Clojure XML library:
  #+BEGIN_SRC clojure
  (require '[clojure.data.xml :as xml])
  #+END_SRC

  #+RESULTS:
  : nil

  Now that we have the library available, we can use it to generate some
  XML. One posibility is to use the =element= function:

  #+BEGIN_SRC clojure
  (let [tags (xml/element :pets {:awesome true}
                          (xml/element :dog)
                          (xml/element :cat)
                          (xml/element :tortoise))]
    (xml/emit-str tags))
  #+END_SRC

  #+RESULTS:
  : <?xml version="1.0" encoding="UTF-8"?><foo foo-attr="foo value"></foo>

** Creating an infinite XML stream

   For further experimenting, it will be handy to have an infinite stream of XML
   data available. Let's create some random data about named animals.

   We start with two vectors from which we are going to pull random combinations:

   #+BEGIN_SRC clojure
   (def animals [:dog :cat :tortoise :axolotl :toucan])
   (def names [:alma :gwyn :mallory :socorro :calvin :cindie :kent :laverna :hisako :marsha])
   #+END_SRC

   #+RESULTS:
   : #'user/animals#'user/names

   Getting random pairs from our vectors is easy:

   #+BEGIN_SRC clojure
   (defn rand-animal []
     (let [animal (rand-nth animals)
           name   (rand-nth names)]
       {:animal animal :name name}))
   #+END_SRC

   #+RESULTS:
   : #'user/rand-animal

   We want to be able to get a XML represantation of each animal:

   #+BEGIN_SRC clojure
   (defn animal->xml [{:keys [animal name]}]
     (xml/element animal {:name name}))
   #+END_SRC

   #+RESULTS:
   : #'user/animal->xml

   To get a number of random animals we can use a function like this:

   #+BEGIN_SRC clojure
   (defn get-animals [num-animals]
     (lazy-seq
      (->> (repeatedly num-animals rand-animal)
           (map animal->xml))))
   #+END_SRC

   #+RESULTS:
   : #'user/get-animals

   Here are 10 random animals, represented in a XML string:

   #+BEGIN_SRC clojure
   (xml/emit-str (get-animals 10))
   #+END_SRC

   #+RESULTS:
   : <?xml version="1.0" encoding="UTF-8"?><dog name=":mallory"></dog><cat name=":cindie"></cat><dog name=":alma"></dog><cat name=":gwyn"></cat><cat name=":alma"></cat><cat name=":mallory"></cat><toucan name=":kent"></toucan><toucan name=":marsha"></toucan><axolotl name=":gwyn"></axolotl><dog name=":kent"></dog>

* Simple XML Parsing

* Handling large XML files


** Reading and writing XML files

   #+BEGIN_SRC clojure
   (require '[clojure.java.io :as io])
   #+END_SRC

   #+RESULTS:
   : nil

   We can write some animals to an XML file like this:

   #+BEGIN_SRC clojure
   (with-open [writer (io/writer "animals.xml")]
     (let [animals (take 50 lazy-animals)
           xml-animals (map animal->xml animals)]
       (xml/emit xml-animals writer)))
   #+END_SRC

   #+RESULTS:
   : #object[java.io.BufferedWriter 0x514ce32d "java.io.BufferedWriter@514ce32d"]

   Reading the XML works similarily:

   #+BEGIN_SRC clojure
   (with-open [reader (io/input-stream (io/file "animals.xml"))]
     (xml/parse reader))
   #+END_SRC

   #+RESULTS:
   : #clojure.data.xml.Element{:tag :petstore, :attrs {}, :content (#clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":laverna"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":gwyn"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":laverna"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":kent"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":kent"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":gwyn"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":mallory"}, :content ()})}


** Lazy evaluation

   So far this was very easy. If you only have to handle files which fit into memory, that might be all you need to know. However, things
   get a bit more challenging if you have to deal with large files. By large I mean >1 GB, depending on your available memory config and
   your JVM configuration.

   #+BEGIN_SRC clojure
   (with-open [reader (io/input-stream (io/file "animals_large.xml"))]
     (doall
      (nth (->> (xml/parse reader)
                :content
                (filter #(= (:tag %) :cat)))
           1000)))
   #+END_SRC

   #+RESULTS:

   #+BEGIN_SRC clojure
   (nth (get-animals 1000000000) 1000000)
   #+END_SRC

   We can prevent head retention by using =dissoc= and passing that to another function:

   #+BEGIN_SRC clojure
   (defn process-pets [head pets n]
     (assoc head :new-pet (nth pets n)))

   (defn wo-head-retention [root n]
     (let [head (dissoc root :pets)
           pets (:pets root)]
       (process-pets head pets n)))
   #+END_SRC

   #+RESULTS:
   : #'user/process-pets#'user/wo-head-retention

   This way, we can go through very long seqs without running out of memory:

   #+BEGIN_SRC clojure
   (let [person {:name "foo"
                 :pets (get-animals 1000000000)}]
     (wo-head-retention person 10000000))
   #+END_SRC

   #+RESULTS:
   : '(:name "foo"  :new-pet #clojure.data.xml.Element(:tag :dog  :attrs (:name :mallory)  :content ()))

   The following code will result in an out of memory exception, because we have head retention through =person=.
   (Running this might crash your JVM or development environment, nevertheless: Give it a try!)

   #+BEGIN_SRC clojure
   (let [person {:name "foo"
                 :pets (get-animals 1000000000)}]
     (assoc person :new-pet (nth (:pets person) 10000000))
     person)
   #+END_SRC

   #+BEGIN_SRC clojure
   (let [person {:name "foo"
                 :pets (get-animals 1000000000)}]
     (identity person)
     (assoc person :new-pet (nth (:pets person) 10000000)))
   #+END_SRC

   #+RESULTS:

* Using event streams
