#+TITLE: XML Processing
#+AUTHOR: Nils Blum-Oeste
#+PROPERTY: header-args :tangle yes

* xml

  Start writing the chapter here.
* Web Resources
  http://blog.korny.info/2014/03/08/xml-for-fun-and-profit.html

* Project Setup

  #+BEGIN_SRC clojure :tangle project.clj
  (defproject clojure-literally/xml "0.1.0-SNAPSHOT"
    :dependencies [[org.clojure/clojure "1.7.0"]
                   [org.clojure/data.xml "0.0.8"]])
  #+END_SRC

* Creating XML

  At first, we want to create some XML with Clojure. Later we will parse the XML
  again.

  Require the Clojure XML library:
  #+BEGIN_SRC clojure
  (require '[clojure.data.xml :as xml])
  #+END_SRC

  #+RESULTS:
  : nil

  Now that we have the library available, we can use it to generate some
  XML. One posibility is to use the =element= function:

  #+BEGIN_SRC clojure
  (let [tags (xml/element :pets {:awesome true}
                          (xml/element :dog)
                          (xml/element :cat)
                          (xml/element :tortoise))]
    (xml/emit-str tags))
  #+END_SRC

  #+RESULTS:
  : <?xml version="1.0" encoding="UTF-8"?><foo foo-attr="foo value"></foo>

** Creating an infinite XML stream

   For further experimenting, it will be handy to have an infinite stream of XML
   data available. Let's create some random data about named animals.

   We start with two vectors from which we are going to pull random combinations:

   #+BEGIN_SRC clojure
   (def animals [:dog :cat :tortoise :axolotl :toucan])
   (def names [:alma :gwyn :mallory :socorro :calvin :cindie :kent :laverna :hisako :marsha])
   #+END_SRC

   Getting random pairs from our vectors is easy:

   #+BEGIN_SRC clojure
   (defn rand-animal []
     (let [animal (rand-nth animals)
           name   (rand-nth names)]
       {:animal animal :name name}))
   #+END_SRC

   We want to be able to get a XML represantation of each animal:

   #+BEGIN_SRC clojure
   (defn animal->xml [{:keys [animal name]}]
     (xml/element animal {:name name}))
   #+END_SRC

   To get a number of random animals we can use a function like this:

   #+BEGIN_SRC clojure
   (defn get-animals [num-animals]
     (->> (repeatedly num-animals rand-animal)
          (map animal->xml)))
   #+END_SRC

   #+RESULTS:
   : #'user/get-animals

   Here are 10 random animals, represented in a XML string:

   #+BEGIN_SRC clojure
   (xml/emit-str (get-animals 10))
   #+END_SRC

   #+RESULTS:
   : <?xml version="1.0" encoding="UTF-8"?><toucan name=":hisako"></toucan><dog name=":mallory"></dog><axolotl name=":hisako"></axolotl><cat name=":marsha"></cat><tortoise name=":calvin"></tortoise><axolotl name=":hisako"></axolotl><tortoise name=":calvin"></tortoise><axolotl name=":hisako"></axolotl><axolotl name=":hisako"></axolotl><toucan name=":socorro"></toucan>

* Simple XML Parsing

* Handling large XML files


** Reading and writing XML files

   #+BEGIN_SRC clojure
   (require '[clojure.java.io :as io])
   #+END_SRC

   #+RESULTS:
   : nil

   We can write some animals to an XML file like this:

   #+BEGIN_SRC clojure
   (with-open [writer (io/writer "animals.xml")]
     (let [animals (take 50 lazy-animals)
           xml-animals (map animal->xml animals)]
       (xml/emit xml-animals writer)))
   #+END_SRC

   #+RESULTS:
   : #object[java.io.BufferedWriter 0x514ce32d "java.io.BufferedWriter@514ce32d"]

   Reading the XML works similarily:

   #+BEGIN_SRC clojure
   (with-open [reader (io/input-stream (io/file "animals.xml"))]
     (xml/parse reader))
   #+END_SRC

   #+RESULTS:
   : #clojure.data.xml.Element{:tag :petstore, :attrs {}, :content (#clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":laverna"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":gwyn"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":laverna"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":marsha"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":calvin"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":alma"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":socorro"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :toucan, :attrs {:name ":mallory"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":kent"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":cindie"}, :content ()} #clojure.data.xml.Element{:tag :cat, :attrs {:name ":kent"}, :content ()} #clojure.data.xml.Element{:tag :dog, :attrs {:name ":hisako"}, :content ()} #clojure.data.xml.Element{:tag :axolotl, :attrs {:name ":gwyn"}, :content ()} #clojure.data.xml.Element{:tag :tortoise, :attrs {:name ":mallory"}, :content ()})}


** Lazy evaluation

   So far this was very easy. If you only have to handle files which fit into memory, that might be all you need to know. However, things
   get a bit more challenging if you have to deal with large files. By large I mean >1 GB, depending on your available memory config and
   your JVM configuration.

   #+BEGIN_SRC clojure
   (with-open [reader (io/input-stream (io/file "animals_large.xml"))]
     (doall
      (nth (->> (xml/parse reader)
                :content
                (filter #(= (:tag %) :cat)))
           1000)))
   #+END_SRC

   #+RESULTS:


* Using event streams
